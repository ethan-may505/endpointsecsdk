///////////////////////////////////////////////////////////////////////////////////////////////
///  Sample Code for HelloWorld
///  Reference Implementation using OPSWAT MetaDefender Endpoint Security SDK
///  
///  Created by Chris Seiler
///  OPSWAT OEM Solutions Architect
///  Mac version adapted by Lucas
///////////////////////////////////////////////////////////////////////////////////////////////
#include "SDKInit.h"



int DetectProducts(wstring* result) {
    // Detect just the patching products here
    const wstring json_in = L"{ \"input\" : { \"method\" : 0} }";
    wa_wchar* json_out = NULL;
    int rc = wa_api_invoke(json_in.c_str(), &json_out);

    if (WAAPI_SUCCESS(rc)) {
        *result += json_out;
    }
    else {
        wcerr << L"[ERROR] Product detection failed.\n";
        if (json_out) {
            wcerr << json_out;
            wa_api_free(json_out);  // Free memory after use
        }
    }

    if (json_out) {
        wa_api_free(json_out);  // Always free memory to prevent leaks
    }

    return rc;
}

int GetVersion(wstring* result, int signatureID) {
    // Convert signatureID to wstring
    wstring signatureIDStr = to_wstring(signatureID);    // Detect just the patching products here
    
    const wstring json_in = L"{ \"input\" : { \"method\" : 100, \"signature\": " + signatureIDStr + L"}}";
    wa_wchar* json_out = NULL;
    int rc = wa_api_invoke(json_in.c_str(), &json_out);

    if (WAAPI_SUCCESS(rc)) {
        *result += json_out;
    }
    else {
        wcerr << L"[ERROR] GetVersion failed.\n";
        if (json_out) {
            wcerr << json_out;
            wa_api_free(json_out);  // Free memory after use
        }
    }

    if (json_out) {
        wa_api_free(json_out);  // Always free memory to prevent leaks
    }

    return rc;
}

vector<int> ExtractSignatureIDs(const json& jsonData) {
    vector<int> signatureIDs;

    try {
        // Navigate to the detected products array
        if (jsonData.contains("result") && jsonData["result"].contains("detected_products")) {
            const auto& detectedProducts = jsonData["result"]["detected_products"];

            // Iterate over each detected product
            for (const auto& product : detectedProducts) {
                if (product.contains("signature")) {
                    int signatureID = product["signature"].get<int>();
                    signatureIDs.push_back(signatureID);
                    cout << "[DEBUG] Found signature ID: " << signatureID << endl;
                }
            }
        }
        else {
            cerr << "[ERROR] Invalid JSON structure: 'result' or 'detected_products' not found." << endl;
        }
    }
    catch (const std::exception& ex) {
        cerr << "[ERROR] Exception during extraction: " << ex.what() << endl;
    }

    return signatureIDs;
}

int ConsumeOfflineVmodDatabase(wstring* result, wstring databasePath) {


    // The file needed for Linux Vulnerability Detection is liv.dat
    const wstring json_in = L"{ \"input\" : { \"method\" : 50520, \"dat_input_source_file\": \"" + databasePath + L"\" } }";
    
    wa_wchar* json_out = NULL;
    int rc = wa_api_invoke(json_in.c_str(), &json_out);

    if (WAAPI_SUCCESS(rc)) {
        *result += json_out;
    }
    else {
        wcerr << L"[ERROR] Product detection failed.\n";
        if (json_out) {
            wcerr << json_out;
        }
    }

    cout << result;

    if (json_out) {
        wa_api_free(json_out);  // Always free memory to prevent leaks
    }

    return rc;
}

int GetProductVulnerability(wstring* result, int signatureID) {
    // Convert signatureID to wstring
    wstring signatureIDStr = to_wstring(signatureID);

    // Construct the JSON input string correctly for vulnerability info
    wstring json_in = L"{ \"input\" : { \"method\" : 1014, \"signature\": " + signatureIDStr + L" } }";
    wa_wchar* json_out = NULL;

    // Invoke the API method
    int rc = wa_api_invoke(json_in.c_str(), &json_out);

    // Check the result
    if (WAAPI_SUCCESS(rc)) {
        if (json_out) {
            *result = json_out;  // Store the output in the result
            wa_api_free(json_out);  // Free memory after use
            wcout << L"[INFO] GetProductVulnerability succeeded for signature ID " << signatureID << L".\n";
        }
        else {
            wcerr << L"[ERROR] GetProductVulnerability succeeded but returned a null output for signature ID " << signatureID << L".\n";
        }
    }
    else {
        
        
        if(rc != WAAPI_ERROR_COMPONENT_METHOD_NOT_IMPLEMENTED)
        {
            wcerr << L"[ERROR] GetProductVulnerability failed for signature ID " << signatureID
            << L" with error code: " << rc << L".\n";
            if (json_out) {
                wcerr << json_out;
                wa_api_free(json_out);  // Free memory after use
            }
        }
    }

    return rc;
}

void ProcessSignatures(const vector<int>& signatureIDs) {
    for (int signatureID : signatureIDs) {
        wstring result;
        
        int status = GetVersion(&result,signatureID);
        wcout << result;
        
        status = GetProductVulnerability(&result, signatureID);

        if (status == 0) {
            wcout << L"[INFO] Success for signature ID " << signatureID << L": " << result << endl;
        }
    }
}

int main() {
    PrintCurrentDirectory();

    if (WAAPI_SUCCESS(SetupOESIS())) {
        
        //
        // Load the detection files
        //
        wstring consumeResult;

        // Load the database for detecting 3rd Party applications
        if (ConsumeOfflineVmodDatabase(&consumeResult,L"mav.dat") != 0) {
            wcerr << L"[ERROR] Failed to consume offline Vmod database.\n";
            wa_api_teardown();
            return -1;
        }

        // Load the database for detecting OS Vulnerabilities
        if (ConsumeOfflineVmodDatabase(&consumeResult,L"v2mod.dat") != 0) {
            wcerr << L"[ERROR] Failed to consume offline Vmod database.\n";
            wa_api_teardown();
            return -1;
        }
        
        wstring productResult;
        if (WAAPI_SUCCESS(DetectProducts(&productResult))) {
            vector<int> signatureIDs = ExtractSignatureIDs(json::parse(wstring_to_utf8(productResult)));
            ProcessSignatures(signatureIDs);
        }
        else {
            wcerr << L"[ERROR] Failed to detect products.\n";
            wcerr << productResult;
        }
        
        wa_api_teardown();
    }
    else {
        wcerr << L"[ERROR] Failed to initialize OESIS.\n";
    }

    return 0;
} 
