from oesis_framework import *
from oesis_generic_product import *

class OesisVulnerabilityAndPatch(OesisGenericProduct):

    def __init__(self, oesis, sig_id):
        self.oesis = oesis
        self.sig_id = sig_id

    def consume_offline_vmod_database(oesis):
        current_dir = os.path.dirname(os.path.abspath(__file__))
        if current_dir.rfind('\\') != -1 :
            dir_path = current_dir[0:current_dir.rfind('\\')] + "\\libs\\vmod.dat"
        else :
            dir_path = current_dir[0:current_dir.rfind('/')] + "/libs/vmod.dat"

        input = {
            "method": METHOD_ID["WAAPI_MID_CONSUME_OFFLINE_VMOD_DATABASE"],
            "dat_input_source_file": dir_path
        }
        rc, json_out = oesis.invoke_method(input)
        return rc, json_out

    def load_patch_database(oesis):
        current_dir = os.path.dirname(os.path.abspath(__file__))
        if current_dir.rfind('\\') != -1 :
            dir_path = current_dir[0:current_dir.rfind('\\')] + "\\libs\\patch.dat"
        else :
            dir_path = current_dir[0:current_dir.rfind('/')] + "/libs/patch.dat"

        input = {
            "method": METHOD_ID["WA_VMOD_PATCH_LOAD_DATABASE"],
            "dat_input_source_file": dir_path
        }
        rc, json_out = oesis.invoke_method(input)
        return rc, json_out

    def get_product_patch_level(self):
        input = {
            "signature": self.sig_id,
            "method": METHOD_ID["WAAPI_MID_GET_PRODUCT_PATCH_LEVEL"]
        }
        rc, json_out = self.oesis.invoke_method(input)
        output = OesisUtils.get_json_value(rc, json_out, ["is_current", "details"])
        return output

    def get_product_vulnerability(self):
        input = {
            "signature": self.sig_id,
            "method": METHOD_ID["WAAPI_MID_GET_PRODUCT_VULNERABILITY"]
        }
        rc, json_out = self.oesis.invoke_method(input)
        output = OesisUtils.get_json_value(rc, json_out, ["has_vulnerability", "has_kb", "severity", "cves", "msbs", "kbs"])
        return output

    def get_remediations(self):
        input = {
            "signature": self.sig_id,
            "method": METHOD_ID["WAAPI_MID_GET_REMEDIATIONS"]
        }
        rc, json_out = self.oesis.invoke_method(input)
        output = OesisUtils.get_json_value(rc, json_out, ["remediation_link"])
        return output

    def get_lastest_installer(self, download=0, path=""):
        input = {
            "signature": self.sig_id,
            "method": METHOD_ID["WA_VMOD_PATCH_GET_LATEST_INSTALLER"],
            "download": download
        }
        if download > 0:
            input["path"] = path
        rc, json_out = self.oesis.invoke_method(input)
        output = OesisUtils.get_json_value(rc, json_out, ["type_id", "patch_id", "index", "eula", "release_note","release_date",
                                            "url", "minimum_version", "language", "architecture", "file_type", "path"])
        return rc, output

    def install_from_file(self, path, force_close = 0):
        input = {
            "signature": self.sig_id,
            "method": METHOD_ID["WA_VMOD_PATCH_INSTALL_FROM_FILES"],
            "path": path,
            "force_close": 0
        }
        if force_close > 0:
            input["force_close"] = force_close
        rc, json_out = self.oesis.invoke_method(input)
        output = OesisUtils.get_json_value(rc, json_out, [])
        return rc, output
